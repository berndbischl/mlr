% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RLearner_spatial_regr_gstat.R
\name{regr.gstat}
\alias{regr.gstat}
\title{gstat regression learner.}
\description{
mlr learner for regression tasks using \link[gstat:gstat]{gstat::gstat}.

This learner does not use the krige interface from gstat. This is because we want to make it the most general as possible.
Therefore the learner makes use the combination of gstat::gstat and gstat::predict to compute spatial predidction.
You can read more this StackOverflow thread : https://stackoverflow.com/questions/13920342/how-to-make-ordinary-kriging-by-using-gstat-predict.

The columns holding the longitude and latitude values must be respectively named x and y

The learner handles gstat variogram autofitting functionnality presented in this post https://www.r-spatial.org/r/2016/02/14/gstat-variogram-fitting.html.
To use manual fitting, you must provide a list to the argument model that holds the following elements :
psill, model, range and nugget.
To use auto fitting, simply provide a list containting the types of models to be tested.
}
\examples{
# loading datasets
library(sp)
data(meuse)
data(meuse.grid)
# imputing values to missing data
meuse = impute(meuse, classes = list(numeric = imputeMean(), factor = imputeMode()),
  dummy.classes = "integer")$data
meuse.grid = impute(meuse.grid, classes = list(numeric = imputeMean(), factor = imputeMode()),
  dummy.classes = "integer")$data
# adding a column with log zinc
meuse = meuse \%>\% dplyr::mutate(log_zinc = log(zinc))
# defining the regression task
task = makeRegrTask(id = "meuse",  data = meuse, target = "log_zinc")
task.krg = dropFeatures(task = task, features = getTaskFeatureNames(task)[-c(1,2)])
# defining the learner with manual variogram fitting
lrn.krg = makeLearner(cl = "regr.gstat", id = "ln(zn) mlr ordinary kriging", predict.type = "response", psill = 1, model = "Sph", range = 900, nugget = 1)
# in case, you want to define the same learner but with automatic variogram fitting use this line instead
lrn.krg.auto = makeLearner(cl = 'regr.gstat', id = 'ln(zn) mlr ordinary kriging autofit',  predict.type = "response", psill = c('Sph','Exp','Gau', 'Mat'))
# training the model
mod.krg = train(lrn.krg, task.krg)
# kriging
newdata.pred.krg = predict(object = mod.krg, newdata = meuse.grid)
ok.mlr = bind_cols(data.frame(meuse.grid), newdata.pred.krg$data)
# mapping
sp::coordinates(ok.mlr) = ~x+y
sp::gridded(ok.mlr) = TRUE
ok.mlr.plot = sp::spplot(ok.mlr["response"], do.log = T, colorkey = TRUE, main = "log(zn) : ok interpolation (gstat)")
# SE - defining the standard error learner by altering the previous one.
se.lrn.krg = setPredictType(lrn.krg, predict.type = "se")
# training the SE model
se.mod.krg = train(se.lrn.krg, task.krg)
# SE kriging
se.newdata.pred.krg = predict(object = se.mod.krg, newdata = meuse.grid)
ok.se.mlr = bind_cols(data.frame(meuse.grid), se.newdata.pred.krg$data)
# SE mapping
sp::coordinates(ok.se.mlr) = ~x+y

}
\references{
Edzer J Pebesma
Multivariable geostatistics in S: the gstat package
Computers & Geosciences Volume 30, Issue 7, 2004, 683-691.
}
