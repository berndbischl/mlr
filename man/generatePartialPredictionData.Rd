% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/generatePartialPrediction.R
\name{generatePartialPredictionData}
\alias{generatePartialPredictionData}
\title{Generate partial predictions}
\usage{
generatePartialPredictionData(obj, data, features, interaction = FALSE,
  fun = mean, resample = "none", fmin = sapply(features, function(x)
  ifelse(!is.factor(data[[x]]), min(data[[x]], na.rm = TRUE), NA)),
  fmax = sapply(features, function(x) ifelse(!is.factor(data[[x]]),
  max(data[[x]], na.rm = TRUE), NA)), gridsize = 10L, ...)
}
\arguments{
\item{obj}{a \code{\link{WrappedModel}} returned from \code{\link{train}}.}

\item{data}{a \code{data.frame} with the same columns as are present in the training data.}

\item{features}{\code{character}\cr
A vector of feature names matching the training data.}

\item{interaction}{\code{logical(1)}\cr
Whether the \code{features} should be interacted or not. If \code{TRUE} then the Cartesian product of the
prediction grid for each feature is taken, and the partial prediction at each unique combination of
values of the features is estimated. Note that if the length of \code{features} is greater than two,
\code{\link{plotPartialPrediction}} and \code{\link{plotPartialPredictionGGVIS}} cannot be used.
If \code{FALSE} each feature is considered separately. In this case \code{features} can be much longer
than two.
Default is \code{FALSE}.}

\item{fun}{for regression, a function that accepts a numeric vector and returns either a single number
such as a measure of location such as the mean, or three numbers, which give a lower bound,
a measure of location, and an upper bound. Note if three numbers are returned they must be
in this order. For classification with \code{predict.type = "prob"} the function must accept
a numeric matrix with the number of columns equal to the number of class levels of the target.
For classification with \code{predict.type = "response"} (the default) the function must accept
a character vector and output a numeric vector with length equal to the number of classes in the
target feature.
The default is the mean, unless \code{obj} is classification with \code{predict.type = "response"}
in which case the default is the proportion of observations predicted to be in each class.}

\item{resample}{\code{character(1)}\cr
Defines how the prediction grid for each feature is created. If \dQuote{bootstrap} then
values are sampled with replacement from the training data. If \dQuote{subsample} then
values are sampled without replacement from the training data. If \dQuote{none} an evenly spaced
grid between either the empirical minimum and maximum, or the minimum and maximum defined by
\code{fmin} and \code{fmax}, is created.
Default is \dQuote{none}.}

\item{fmin}{\code{numeric}\cr
The minimum value that each element of \code{features} can take.
This argument is only applicable if \code{resample = NULL} and when the empirical minimum is higher
than the theoretical minimum for a given feature.
Default is the empirical minimum of each numeric feature and NA for factor features.}

\item{fmax}{\code{numeric}\cr
The maximum value that each element of \code{features} can take.
This argument is only applicable if \code{resample = "none"} and when the empirical maximum is lower
than the theoretical maximum for a given feature.
Default is the empirical maximum of each numeric feature and NA for factor features.}

\item{gridsize}{\code{integer(1)}\cr
The length of the prediction grid created for each feature.
If \code{resample = "bootstrap"} or \code{resample = "subsample"} then this defines
the number of (possibly non-unique) values resampled. If \code{resample = NULL} it defines the
length of the evenly spaced grid created.}

\item{...}{additional arguments to be passed to \code{\link{predict}}.}
}
\value{
an object of class \code{PartialPredictionData}, a named list, which contains the data,
  the target, the features, and the task description.
}
\description{
Estimate how the learned prediction function is affected by one or more features
}
\examples{
lrn = makeLearner("classif.rpart", predict.type = "prob")
fit = train(lrn, iris.task)
pd = generatePartialPredictionData(fit, getTaskData(iris.task), c("Petal.Width", "Petal.Length"))
plotPartialPrediction(pd)
}
\seealso{
Other generate_plot_data: \code{\link{generateBenchmarkSummaryData}};
  \code{\link{generateCalibrationData}};
  \code{\link{generateCritDifferencesData}};
  \code{\link{generateFilterValuesData}};
  \code{\link{generateLearningCurveData}};
  \code{\link{generateROCRCurvesData}};
  \code{\link{generateRankMatrixAsBarData}};
  \code{\link{generateThreshVsPerfData}};
  \code{\link{getFilterValues}}

Other partial_prediction: \code{\link{plotPartialPredictionGGVIS}};
  \code{\link{plotPartialPrediction}}
}

